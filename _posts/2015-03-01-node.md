---
layout: post
title: why Node? for beginners
---
###UNDERSTANDING NODE AS A BEGINNER

Learning to program isn't just learning a single language, but also learning the systems of technologies which support the deployment of applications in that language. So if you're beginning to learn how to program, one of the more difficult challenges is to understand the **context** of the technologies you're learning. 

For instance, the vast majority of books written to teach a programming language or technology will frustratingly define crucial terms of that language by drawing analogies to other languages or technologies. So for instance, the Node.js site [defines Node](http://nodejs.org/about/) as being:
 *"similar in design to and influenced by systems like Ruby's Event Machine or Python's twisted. Node takes the event model a bit further, it presents the event loop as a language construct instead of a library."*

So if someone's learning Node as their first web development framework, how can she understand the context of what she's learning? Understanding the context of a technology and being able to justify its advantages deepens someone's understanding of programming, and also helps quite a lot during job interviews. Let's take a look at how Nodejs.org defines Node. In part II of this post, I'll explain how these characteristics allow for Node's chief advantages. 

###NODEJS.ORG
<a href="http://nodejs.org/"><img src="{{ site.baseurl }}/images/aboutnode.png" style="width: 700px; display: block; margin: auto;"/></a>

So what's this all mean? Naturally, the definition includes a lot of language that's pretty opaque to programming beginners. So let's unpack the definition by defining our terms. 

###CHROME'S JAVASCRIPT RUNTIME
Node uses Chrome's V8 engine to run JavaScript. The V8 engine, which is also found in the Chrome web browser, is a [virtual machine](http://en.wikipedia.org/wiki/Virtual_machine), or something that simulates a computer system in running code. 

###NON-BLOCKING
What is non-blocking programming? How can we contextualize this relative to Node and JavaScript? [“Non-blocking programming](http://www.toptal.com/javascript/guide-to-full-stack-javascript-initjs) aims to put time-consuming tasks off to the side, usually by specifying what should be done when these tasks are complete, and allowing the processor to handle other requests in the meantime.” This is also known as "asynchronous" programming. This is contrast to "blocking" code, which waits until the task is finished before handling any other requests. 

What are some of these time-consuming tasks asynchronous programming helps us do more efficiently? (Keep in mind that time-consuming for a computer means anything that takes more than a few milliseconds.) They're things like retrieving data from databases, querying external APIs, or saving files--anything which needs to use something that exists outside of the application's code. 

JavaScript facilitates Node's non-blocking qualities with its ability to handle asynchronous code.With JavaScript, any process which takes a long time to execute will be handled by a function with a callback. That means that a function will be called, the code after that function will be executed, and then when that function returns with its data, the callback function will be run. (For more on understanding JavaScript’s callback functions, check out [this](http://javascriptissexy.com/understand-javascript-callback-functions-and-use-them/) blog post.) 

###EVENT-DRIVEN
So how is JavaScript able to handle asynchronous code? An engine (like V8) that runs JavaScript uses an *event loop* in order to handle the execution of callback functions without blocking. The event loop is a concept which refers to the queue of callback functions stored in the JavaScript engine. When an async function is called, the function in the callback( whatever code should be executed when the function returns) is put onto the queue. The event loop isn't processed by the JavaScript engine until the code after the async function has been executed. 

This concept is a little difficult understand--here's a [great video](http://vimeo.com/96425312?utm_source=nodeweekly&utm_medium=email)which gives a super easy-to-understand explanation of the event loop and just what happens when JavaScript is executed, in general.

###I/O
So Node.js handles I/O with asynchronous functions and the JavaScript event loop. I/O is short for *input/output*, which refers to any communication between a computing system and the outside world. For instance, the keyboard and trackpad of a computer are methods of input to the machine, while a monitor or printer provides output. I/O is a conceptual term, and can be extended to the general concepts of input and output--for instance, any data transfer from the CPU and memory (stuff that exists in RAM) to anything else (for instance, hard disk storage) is considered I/O. . 

Any form of I/O generally falls in the category of "things which take a long time to do". Other programming frameworks might handle one I/O request a time synchronously, or start a new *process* or *thread* for each request. (No need to worry about the difference between a process or a thread right now, just know that a single process or thread is a ["independent sequence of execution"](http://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread), like a single train track running through code.)

When Node handles I/O, it uses asynchronous code on a single thread. So an I/O call is made. The event loop works to save the callback and then returns control to the Node.js runtime environment. The callback is called later, when the data is actually available. 